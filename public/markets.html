<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic Market Overview - Space Trader</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0b1016;
            --bg-elevated: #121a24;
            --panel: #0f1724;
            --panel-border: rgba(45, 212, 191, 0.3);
            --text: #e2e8f0;
            --muted: #93a4b7;
            --accent: #2dd4bf;
            --warning: #f59e0b;
            --danger: #f87171;
            --success: #10b981;
            --info: #60a5fa;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: "Space Grotesk", sans-serif;
            background: var(--bg);
            color: var(--text);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        .header {
            background: var(--bg-elevated);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 8px;
        }

        .header p {
            color: var(--muted);
            font-size: 14px;
        }

        .meta-row {
            display: flex;
            gap: 20px;
            margin-top: 12px;
            font-size: 13px;
            color: var(--muted);
        }

        .panel {
            background: var(--panel);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .panel h2 {
            font-size: 20px;
            margin-bottom: 16px;
        }

        .good-stats {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }

        .good-card {
            background: var(--bg-elevated);
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 16px;
        }

        .good-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .good-name {
            font-weight: 600;
            font-size: 16px;
        }

        .good-base-price {
            color: var(--muted);
            font-size: 13px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .stat-label {
            color: var(--muted);
        }

        .stat-value {
            font-weight: 500;
        }

        .stock-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .stock-low { background: var(--danger); }
        .stock-medium { background: var(--warning); }
        .stock-high { background: var(--success); }

        .price-indicator {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .price-low { background: rgba(16, 185, 129, 0.2); color: var(--success); }
        .price-normal { background: rgba(147, 164, 183, 0.2); color: var(--muted); }
        .price-high { background: rgba(248, 113, 113, 0.2); color: var(--danger); }

        .request-badge {
            display: inline-block;
            background: rgba(45, 212, 191, 0.2);
            color: var(--accent);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
        }

        .heatmap-container {
            overflow-x: auto;
            margin-top: 20px;
        }

        .heatmap {
            border-collapse: collapse;
            width: 100%;
            font-size: 11px;
        }

        .heatmap th {
            background: var(--bg-elevated);
            padding: 8px;
            text-align: left;
            position: sticky;
            left: 0;
            z-index: 2;
            border: 1px solid var(--panel-border);
        }

        .heatmap td {
            padding: 6px 8px;
            border: 1px solid var(--panel-border);
            text-align: center;
            min-width: 80px;
        }

        .heatmap-cell {
            padding: 4px;
            border-radius: 4px;
        }

        .cell-stock-0 { background: rgba(248, 113, 113, 0.3); }
        .cell-stock-1 { background: rgba(248, 113, 113, 0.2); }
        .cell-stock-2 { background: rgba(245, 158, 11, 0.2); }
        .cell-stock-3 { background: rgba(16, 185, 129, 0.2); }
        .cell-stock-4 { background: rgba(16, 185, 129, 0.3); }

        .cell-price-low { color: var(--success); }
        .cell-price-high { color: var(--danger); }

        .request-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent);
            margin-left: 4px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: var(--muted);
        }

        .error {
            text-align: center;
            padding: 40px;
            color: var(--danger);
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }

        .summary-card {
            background: var(--bg-elevated);
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 16px;
            text-align: center;
        }

        .summary-value {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .summary-label {
            color: var(--muted);
            font-size: 13px;
        }

        .summary-monitor {
            margin-top: 16px;
            padding: 14px 16px;
            background: var(--bg-elevated);
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            font-size: 13px;
            color: var(--muted);
            line-height: 1.5;
        }

        .summary-monitor strong {
            color: var(--text);
            font-weight: 600;
        }

        .map-container {
            position: relative;
            width: 100%;
            height: 420px;
            background: radial-gradient(circle at top, rgba(45, 212, 191, 0.12), transparent 55%), var(--bg);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            overflow: hidden;
        }

        .map-tooltip {
            position: absolute;
            background: rgba(8, 15, 24, 0.95);
            border: 1px solid rgba(45, 212, 191, 0.5);
            padding: 10px;
            border-radius: 10px;
            color: var(--text);
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            white-space: pre-line;
        }

        .map-legend {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 12px;
            font-size: 12px;
            color: var(--muted);
        }

        .map-legend-bar {
            width: 160px;
            height: 8px;
            border-radius: 999px;
            background: linear-gradient(90deg, var(--danger), var(--warning), var(--success));
        }

        .heatmap tr.active-row th,
        .heatmap tr.active-row td {
            box-shadow: inset 0 0 0 2px rgba(45, 212, 191, 0.7);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Galactic Market Overview</h1>
            <p>Pricing and incentive system health monitoring</p>
            <div class="meta-row">
                <div id="lastUpdated">Last update: --</div>
                <div>Market refresh: 60s · Map refresh: 60s</div>
                <div id="loadProgress">Loaded 0/0 systems</div>
            </div>
        </div>

        <div id="summary" class="panel" style="display: none;">
            <h2>Summary</h2>
            <div class="summary-grid" id="summaryGrid"></div>
            <div class="summary-monitor" id="monitorSummary"></div>
        </div>

        <div id="goodStats" class="panel" style="display: none;">
            <h2>Good Statistics</h2>
            <div class="good-stats" id="goodStatsGrid"></div>
        </div>

        <div id="galaxyMapPanel" class="panel" style="display: none;">
            <h2>Market Health Map</h2>
            <p style="color: var(--muted); font-size: 13px; margin-bottom: 16px;">
                Each system is colored by stock health from the heatmap. Red = low stock pressure, green = healthy stock.
                Click a system to jump to its heatmap row.
            </p>
            <div id="marketMapContainer" class="map-container">
                <svg id="marketGalaxyMap" width="100%" height="100%" style="display: block;"></svg>
                <div id="marketMapTooltip" class="map-tooltip"></div>
            </div>
            <div class="map-legend">
                <span>Low stock</span>
                <div class="map-legend-bar"></div>
                <span>High stock</span>
            </div>
        </div>

        <div id="heatmap" class="panel" style="display: none;">
            <h2>Stock Levels Heatmap</h2>
            <p style="color: var(--muted); font-size: 13px; margin-bottom: 16px;">
                Shows stock ratio (inventory / expected stock). Darker red = lower stock, darker green = higher stock.
                <span class="request-indicator"></span> = Active request/incentive
            </p>
            <div class="heatmap-container">
                <table class="heatmap" id="heatmapTable"></table>
            </div>
        </div>

        <div id="loading" class="loading">Loading market data...</div>
        <div id="error" class="error" style="display: none;"></div>
    </div>

    <script>
        const API_BASE = window.location.origin;
        const MARKET_BATCH_SIZE = 10;
        const MARKET_REFRESH_MS = 60000;
        const MAP_REFRESH_MS = 60000;

        let marketRefreshInterval;
        let mapRefreshInterval;
        let loadGeneration = 0;
        let hasInitialLoad = false;

        const marketState = {
            goods: [],
            systems: new Map(),
            totalSystems: 0,
            monitoringSummary: null,
            deliveryStats: null,
            deliveryByGood: new Map(),
            selectedSystemId: null,
        };

        const mapState = {
            systems: [],
            nodeById: new Map(),
        };

        async function fetchMarketData() {
            const currentLoad = ++loadGeneration;
            const isInitialLoad = !hasInitialLoad;
            const seenSystems = new Set();
            const deliveryAccumulator = {
                totalAvailable: 0,
                totalAccepted: 0,
                byGood: new Map(),
                hasSample: false,
            };
            let refreshComplete = true;

            if (isInitialLoad) {
                resetMarketState();
                updateLoadProgress(0, 0);
                document.getElementById('loading').style.display = 'block';
            } else {
                updateLoadProgress(marketState.systems.size, marketState.totalSystems, true);
            }
            document.getElementById('error').style.display = 'none';

            let initialBatch;
            try {
                initialBatch = await fetchMarketBatch(0, MARKET_BATCH_SIZE);
            } catch (error) {
                if (currentLoad !== loadGeneration) return;
                if (isInitialLoad) {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error').style.display = 'block';
                    document.getElementById('error').textContent = `Error: ${error.message}`;
                } else {
                    document.getElementById('error').style.display = 'block';
                    document.getElementById('error').textContent = `Refresh error: ${error.message}`;
                    updateLoadProgress(marketState.systems.size, marketState.totalSystems);
                }
                return;
            }

            if (currentLoad !== loadGeneration) return;
            if (!initialBatch) return;

            applyBatchData(initialBatch, seenSystems, !isInitialLoad, deliveryAccumulator, false);
            if (isInitialLoad) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('summary').style.display = 'block';
                document.getElementById('goodStats').style.display = 'block';
                document.getElementById('heatmap').style.display = 'block';
                hasInitialLoad = true;
            }
            updateLastUpdated();

            const totalSystems = marketState.totalSystems || 0;
            for (let start = MARKET_BATCH_SIZE; start < totalSystems; start += MARKET_BATCH_SIZE) {
                if (currentLoad !== loadGeneration) return;
                try {
                    const batch = await fetchMarketBatch(start, MARKET_BATCH_SIZE);
                    if (!batch) continue;
                    if (currentLoad !== loadGeneration) return;
                    applyBatchData(batch, seenSystems, !isInitialLoad, deliveryAccumulator, false);
                } catch (error) {
                    refreshComplete = false;
                    break;
                }
            }

            if (currentLoad === loadGeneration && refreshComplete) {
                renderSummary(buildViewModel());
                updateLoadProgress(marketState.systems.size, marketState.totalSystems);
            }
        }

        async function fetchMarketBatch(start, limit) {
            const response = await fetch(`${API_BASE}/api/galaxy/markets?start=${start}&limit=${limit}`);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            return await response.json();
        }

        function resetMarketState() {
            marketState.goods = [];
            marketState.systems.clear();
            marketState.totalSystems = 0;
            marketState.monitoringSummary = null;
            marketState.deliveryStats = null;
            marketState.deliveryByGood.clear();
            marketState.selectedSystemId = null;
        }

        function applyBatchData(data, seenSystems, isUpdating = false, deliveryAccumulator = null, renderSummaryNow = true) {
            if (Array.isArray(data.goods) && data.goods.length > 0) {
                marketState.goods = data.goods;
            }
            if (Number.isFinite(data.totalSystems)) {
                marketState.totalSystems = data.totalSystems;
            }
            if (data.monitoringSummary) {
                marketState.monitoringSummary = data.monitoringSummary;
            }
            if (deliveryAccumulator && data.deliveryStats) {
                if (!deliveryAccumulator.hasSample) {
                    deliveryAccumulator.byGood.clear();
                    deliveryAccumulator.totalAvailable = 0;
                    deliveryAccumulator.totalAccepted = 0;
                    deliveryAccumulator.hasSample = true;
                }
                deliveryAccumulator.totalAvailable += data.deliveryStats.totalAvailable || 0;
                deliveryAccumulator.totalAccepted += data.deliveryStats.totalAccepted || 0;
            }
            if (deliveryAccumulator && data.goodStats) {
                for (const stat of Object.values(data.goodStats)) {
                    if (stat.availableDeliveries !== undefined || stat.acceptedDeliveries !== undefined) {
                        if (!deliveryAccumulator.hasSample) {
                            deliveryAccumulator.byGood.clear();
                            deliveryAccumulator.totalAvailable = 0;
                            deliveryAccumulator.totalAccepted = 0;
                            deliveryAccumulator.hasSample = true;
                        }
                        const current = deliveryAccumulator.byGood.get(stat.goodId) || { available: 0, accepted: 0 };
                        current.available += stat.availableDeliveries || 0;
                        current.accepted += stat.acceptedDeliveries || 0;
                        deliveryAccumulator.byGood.set(stat.goodId, current);
                    }
                }
            }
            if (deliveryAccumulator && deliveryAccumulator.hasSample) {
                marketState.deliveryStats = {
                    totalAvailable: deliveryAccumulator.totalAvailable,
                    totalAccepted: deliveryAccumulator.totalAccepted,
                    totalActive: deliveryAccumulator.totalAvailable + deliveryAccumulator.totalAccepted,
                };
                marketState.deliveryByGood = new Map(deliveryAccumulator.byGood);
            }
            for (const system of data.systems || []) {
                marketState.systems.set(system.id, system);
                if (seenSystems) {
                    seenSystems.add(system.id);
                }
            }
            renderFromState({ skipSummary: !renderSummaryNow });
            updateLoadProgress(marketState.systems.size, marketState.totalSystems, isUpdating);
        }

        function updateLoadProgress(loaded, total, isUpdating = false) {
            const target = document.getElementById('loadProgress');
            const label = total > 0 ? `${loaded}/${total}` : `${loaded}`;
            target.textContent = `${isUpdating ? 'Updating' : 'Loaded'} ${label} systems`;
        }

        function updateLastUpdated() {
            const now = new Date();
            document.getElementById('lastUpdated').textContent = 
                `Last update: ${now.toLocaleTimeString()}`;
        }

        function buildViewModel() {
            const systems = Array.from(marketState.systems.values()).sort((a, b) => a.id - b.id);
            const goodStats = computeGoodStats(marketState.goods, systems, marketState.deliveryByGood);
            return {
                goods: marketState.goods,
                systems,
                goodStats,
                monitoringSummary: marketState.monitoringSummary,
                deliveryStats: marketState.deliveryStats,
                sampleSize: systems.length,
                totalSystems: marketState.totalSystems,
            };
        }

        function renderFromState(options = {}) {
            const viewModel = buildViewModel();
            if (!options.skipSummary) {
                renderSummary(viewModel);
            }
            renderGoodStats(viewModel.goods, viewModel.goodStats);
            renderHeatmap(viewModel);
            applyGalaxyMapColors();
        }

        function computeGoodStats(goods, systems, deliveryByGood) {
            const stats = {};
            const totals = new Map();

            for (const good of goods) {
                stats[good.goodId] = {
                    goodId: good.goodId,
                    name: good.name,
                    basePrice: good.basePrice,
                    avgPrice: 0,
                    avgPriceRatio: 1,
                    avgStockRatio: 1,
                    lowStockCount: 0,
                    requestCount: 0,
                    totalRemainingUnits: 0,
                    avgBonusPerUnit: 0,
                    systemsWithLowStock: [],
                };
                totals.set(good.goodId, {
                    count: 0,
                    totalPrice: 0,
                    totalPriceRatio: 0,
                    totalStockRatio: 0,
                    lowStockCount: 0,
                    requestCount: 0,
                    totalRemainingUnits: 0,
                    totalBonus: 0,
                    systemsWithLowStock: [],
                });
            }

            for (const system of systems) {
                const markets = system.markets || {};
                for (const [goodId, market] of Object.entries(markets)) {
                    const total = totals.get(goodId);
                    if (!total) continue;
                    total.count++;
                    total.totalPrice += market.price;
                    total.totalPriceRatio += market.priceRatio;
                    total.totalStockRatio += market.stockRatio;

                    if (market.stockRatio < 0.5) {
                        total.lowStockCount++;
                        total.systemsWithLowStock.push(system.id);
                    }

                    if (market.hasRequest) {
                        total.requestCount++;
                        total.totalRemainingUnits += market.remainingUnits || 0;
                        total.totalBonus += market.bonusPerUnit || 0;
                    }
                }
            }

            for (const good of goods) {
                const total = totals.get(good.goodId);
                if (!total) continue;
                const count = total.count;
                const stat = stats[good.goodId];
                stat.avgPrice = count > 0 ? total.totalPrice / count : 0;
                stat.avgPriceRatio = count > 0 ? total.totalPriceRatio / count : 1;
                stat.avgStockRatio = count > 0 ? total.totalStockRatio / count : 1;
                stat.lowStockCount = total.lowStockCount;
                stat.requestCount = total.requestCount;
                stat.totalRemainingUnits = total.totalRemainingUnits;
                stat.avgBonusPerUnit = total.requestCount > 0 ? total.totalBonus / total.requestCount : 0;
                stat.systemsWithLowStock = total.systemsWithLowStock;

                const deliveries = deliveryByGood.get(good.goodId);
                if (deliveries) {
                    stat.availableDeliveries = deliveries.available;
                    stat.acceptedDeliveries = deliveries.accepted;
                }
            }

            return stats;
        }

        function renderSummary(data) {
            const goodStats = data.goodStats;
            const statsValues = Object.values(goodStats);
            const totalLowStock = statsValues.reduce((sum, g) => sum + g.lowStockCount, 0);
            const totalRequests = statsValues.reduce((sum, g) => sum + g.requestCount, 0);
            const totalRemaining = statsValues.reduce((sum, g) => sum + g.totalRemainingUnits, 0);
            const avgStockRatio = statsValues.length > 0
                ? statsValues.reduce((sum, g) => sum + g.avgStockRatio, 0) / statsValues.length
                : 0;

            const grid = document.getElementById('summaryGrid');
            const totalSystems = Number.isFinite(data.totalSystems) ? data.totalSystems : 0;
            const systemLabel = totalSystems > 0
                ? `Systems Loaded (${data.sampleSize}/${totalSystems})`
                : 'Systems Loaded';

            grid.innerHTML = `
                <div class="summary-card">
                    <div class="summary-value">${data.sampleSize}</div>
                    <div class="summary-label">${systemLabel}</div>
                </div>
                <div class="summary-card">
                    <div class="summary-value">${totalLowStock}</div>
                    <div class="summary-label">Low Stock Markets</div>
                </div>
                <div class="summary-card">
                    <div class="summary-value">${totalRequests}</div>
                    <div class="summary-label">Active Requests</div>
                </div>
                <div class="summary-card">
                    <div class="summary-value">${totalRemaining.toLocaleString()}</div>
                    <div class="summary-label">Units Needed</div>
                </div>
                <div class="summary-card">
                    <div class="summary-value">${(avgStockRatio * 100).toFixed(1)}%</div>
                    <div class="summary-label">Avg Stock Ratio</div>
                </div>
                <div class="summary-card">
                    <div class="summary-value">${data.deliveryStats?.totalActive || 0}</div>
                    <div class="summary-label">Active Deliveries</div>
                </div>
                <div class="summary-card">
                    <div class="summary-value">${data.deliveryStats?.totalAccepted || 0}</div>
                    <div class="summary-label">In Transit</div>
                </div>
            `;

            const monitor = document.getElementById('monitorSummary');
            const summary = data.monitoringSummary;
            if (!summary) {
                monitor.textContent = 'Monitoring snapshot not available yet. Waiting for the self-balance monitor.';
                return;
            }

            const ageSeconds = Math.max(0, Math.floor((Date.now() - summary.timestamp) / 1000));
            const ageLabel = ageSeconds < 120
                ? `${ageSeconds}s ago`
                : `${Math.round(ageSeconds / 60)}m ago`;

            const worstGoods = (summary.worstGoods || []).map((good) => {
                const name = goodStats[good.goodId]?.name || good.goodId;
                return `${name} ${(good.averageInventoryRatio * 100).toFixed(0)}%`;
            });

            monitor.innerHTML = `
                <strong>Monitoring snapshot</strong> · ${ageLabel}<br>
                Zero inventory markets (&lt;1 unit): <strong>${summary.zeroInventoryMarkets}</strong> / ${summary.totalMarkets} ·
                Near-zero (&lt;0.5%) markets: <strong>${summary.nearZeroInventoryMarkets}</strong> ·
                Low inventory markets: <strong>${summary.lowInventoryMarkets}</strong> ·
                Avg inventory ratio: <strong>${(summary.averageInventoryRatio * 100).toFixed(1)}%</strong><br>
                Weakest goods: <strong>${worstGoods.length ? worstGoods.join(', ') : 'None'}</strong>
            `;
        }

        function renderGoodStats(goods, goodStats) {
            const grid = document.getElementById('goodStatsGrid');
            grid.innerHTML = '';

            if (!goods || goods.length === 0) {
                grid.innerHTML = '<div class="loading">Loading goods...</div>';
                return;
            }

            const sorted = [...goods].sort((a, b) => a.basePrice - b.basePrice);

            for (const good of sorted) {
                const stat = goodStats[good.goodId];
                if (!stat) continue;

                const stockClass = stat.avgStockRatio < 0.3 ? 'stock-low' : 
                                  stat.avgStockRatio < 0.7 ? 'stock-medium' : 'stock-high';
                const priceClass = stat.avgPriceRatio < 0.9 ? 'price-low' :
                                  stat.avgPriceRatio > 1.1 ? 'price-high' : 'price-normal';

                const card = document.createElement('div');
                card.className = 'good-card';
                card.innerHTML = `
                    <div class="good-card-header">
                        <div>
                            <span class="good-name">${stat.name}</span>
                            ${stat.requestCount > 0 ? `<span class="request-badge">${stat.requestCount} requests</span>` : ''}
                        </div>
                        <div class="good-base-price">Base: ${stat.basePrice}cr</div>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Avg Stock Ratio</span>
                        <span class="stat-value">
                            <span class="stock-indicator ${stockClass}"></span>
                            ${(stat.avgStockRatio * 100).toFixed(1)}%
                        </span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Avg Price</span>
                        <span class="stat-value">
                            <span class="price-indicator ${priceClass}">${stat.avgPrice.toFixed(1)}cr</span>
                            (${(stat.avgPriceRatio * 100).toFixed(0)}% of base)
                        </span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Low Stock Systems</span>
                        <span class="stat-value">${stat.lowStockCount}</span>
                    </div>
                    ${stat.availableDeliveries !== undefined ? `
                    <div class="stat-row">
                        <span class="stat-label">Available Deliveries</span>
                        <span class="stat-value" style="color: var(--accent);">${stat.availableDeliveries}</span>
                    </div>
                    ` : ''}
                    ${stat.acceptedDeliveries !== undefined ? `
                    <div class="stat-row">
                        <span class="stat-label">Deliveries In Transit</span>
                        <span class="stat-value" style="color: var(--info);">${stat.acceptedDeliveries}</span>
                    </div>
                    ` : ''}
                    ${stat.requestCount > 0 ? `
                    <div class="stat-row">
                        <span class="stat-label">Avg Bonus/Unit</span>
                        <span class="stat-value">${stat.avgBonusPerUnit.toFixed(1)}cr</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Total Units Needed</span>
                        <span class="stat-value">${stat.totalRemainingUnits.toLocaleString()}</span>
                    </div>
                    ` : ''}
                `;
                grid.appendChild(card);
            }
        }

        function renderHeatmap(data) {
            const table = document.getElementById('heatmapTable');
            const goods = data.goods || [];
            const systems = data.systems || [];

            if (goods.length === 0) {
                table.innerHTML = '<tbody><tr><td style="padding: 12px;">Waiting for goods...</td></tr></tbody>';
                return;
            }

            const sortedGoods = [...goods].sort((a, b) => a.basePrice - b.basePrice);

            // Build header
            let html = '<thead><tr><th>System</th>';
            for (const good of sortedGoods) {
                html += `<th>${good.name}</th>`;
            }
            html += '</tr></thead><tbody>';

            if (systems.length === 0) {
                html += `<tr><td colspan="${sortedGoods.length + 1}" style="padding: 16px;">No systems loaded yet.</td></tr>`;
                html += '</tbody>';
                table.innerHTML = html;
                return;
            }

            // Build rows
            for (const system of systems) {
                const activeClass = marketState.selectedSystemId === system.id ? ' class="active-row"' : '';
                html += `<tr id="system-row-${system.id}" data-system-id="${system.id}"${activeClass}><th>${system.id}</th>`;
                for (const good of sortedGoods) {
                    const market = system.markets[good.goodId];
                    if (!market) {
                        html += '<td>-</td>';
                        continue;
                    }

                    const stockRatio = market.stockRatio;
                    let stockClass = 'cell-stock-2';
                    if (stockRatio < 0.2) stockClass = 'cell-stock-0';
                    else if (stockRatio < 0.5) stockClass = 'cell-stock-1';
                    else if (stockRatio < 0.8) stockClass = 'cell-stock-2';
                    else if (stockRatio < 1.2) stockClass = 'cell-stock-3';
                    else stockClass = 'cell-stock-4';

                    const priceClass = market.priceRatio < 0.9 ? 'cell-price-low' :
                                      market.priceRatio > 1.1 ? 'cell-price-high' : '';

                    const requestIndicator = market.hasRequest ? '<span class="request-indicator"></span>' : '';

                    html += `<td class="${stockClass}">
                        <div class="heatmap-cell ${priceClass}">
                            ${(stockRatio * 100).toFixed(0)}%${requestIndicator}
                            <div style="font-size: 9px; color: var(--muted); margin-top: 2px;">
                                ${Math.round(market.inventory)} units
                            </div>
                            <div style="font-size: 9px; color: var(--muted); margin-top: 2px;">
                                ${market.price.toFixed(0)}cr
                            </div>
                        </div>
                    </td>`;
                }
                html += '</tr>';
            }

            html += '</tbody>';
            table.innerHTML = html;
        }

        async function refreshGalaxyMap() {
            const svg = document.getElementById('marketGalaxyMap');
            if (!svg) return;

            try {
                const response = await fetch(`${API_BASE}/api/galaxy/map`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                mapState.systems = data.systems || [];
                renderGalaxyMap();
                document.getElementById('galaxyMapPanel').style.display = 'block';
            } catch (error) {
                svg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#f87171" font-size="14">Error loading galaxy map</text>';
                document.getElementById('galaxyMapPanel').style.display = 'block';
            }
        }

        function renderGalaxyMap() {
            const svg = document.getElementById('marketGalaxyMap');
            const tooltip = document.getElementById('marketMapTooltip');
            const container = document.getElementById('marketMapContainer');
            if (!svg || !container) return;

            const systems = mapState.systems || [];
            if (systems.length === 0) {
                svg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#93a4b7" font-size="14">No systems available</text>';
                return;
            }

            svg.innerHTML = '';
            mapState.nodeById.clear();

            const width = svg.clientWidth || 800;
            const height = svg.clientHeight || 420;

            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            systems.forEach(sys => {
                minX = Math.min(minX, sys.x);
                maxX = Math.max(maxX, sys.x);
                minY = Math.min(minY, sys.y);
                maxY = Math.max(maxY, sys.y);
            });

            const padding = 20;
            const rangeX = maxX - minX || 128;
            const rangeY = maxY - minY || 128;
            const scaleX = (width - padding * 2) / rangeX;
            const scaleY = (height - padding * 2) / rangeY;
            const scale = Math.min(scaleX, scaleY);

            const centerX = width / 2;
            const centerY = height / 2;
            const offsetX = (minX + maxX) / 2;
            const offsetY = (minY + maxY) / 2;

            const worldToScreen = (wx, wy) => {
                const screenX = centerX + (wx - offsetX) * scale;
                const screenY = centerY + (wy - offsetY) * scale;
                return { x: screenX, y: screenY };
            };

            systems.forEach((sys) => {
                const screenPos = worldToScreen(sys.x, sys.y);
                const x = screenPos.x;
                const y = screenPos.y;

                if (x < -10 || x > width + 10 || y < -10 || y > height + 10) return;

                const systemCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                systemCircle.setAttribute("cx", x);
                systemCircle.setAttribute("cy", y);
                systemCircle.setAttribute("r", "3");
                systemCircle.setAttribute("fill", getSystemHeatColor(sys.id));
                systemCircle.setAttribute("stroke", "rgba(11, 16, 22, 0.8)");
                systemCircle.setAttribute("stroke-width", "1");
                systemCircle.style.cursor = "pointer";

                svg.appendChild(systemCircle);
                mapState.nodeById.set(sys.id, systemCircle);

                systemCircle.addEventListener("mouseenter", (event) => {
                    const stats = getSystemHeatStats(sys.id);
                    let tooltipText = `System ${sys.id}`;
                    if (stats.totalCount > 0) {
                        tooltipText += `\nRed markets: ${stats.redCount}`;
                        tooltipText += `\nGreen markets: ${stats.greenCount}`;
                        tooltipText += `\nNeutral markets: ${stats.neutralCount}`;
                    } else {
                        tooltipText += '\nNo market data loaded yet.';
                    }

                    const rect = container.getBoundingClientRect();
                    tooltip.textContent = tooltipText;
                    tooltip.style.left = `${event.clientX - rect.left + 10}px`;
                    tooltip.style.top = `${event.clientY - rect.top + 10}px`;
                    tooltip.style.display = "block";
                    systemCircle.setAttribute("r", "5");
                });

                systemCircle.addEventListener("mousemove", (event) => {
                    const rect = container.getBoundingClientRect();
                    tooltip.style.left = `${event.clientX - rect.left + 10}px`;
                    tooltip.style.top = `${event.clientY - rect.top + 10}px`;
                });

                systemCircle.addEventListener("mouseleave", () => {
                    tooltip.style.display = "none";
                    systemCircle.setAttribute("r", "3");
                });

                systemCircle.addEventListener("click", () => {
                    scrollToSystemRow(sys.id);
                });
            });
        }

        function applyGalaxyMapColors() {
            if (!mapState.nodeById.size) return;
            for (const [systemId, node] of mapState.nodeById.entries()) {
                node.setAttribute("fill", getSystemHeatColor(systemId));
            }
        }

        function getSystemHeatStats(systemId) {
            const system = marketState.systems.get(systemId);
            if (!system || !system.markets) {
                return { redCount: 0, greenCount: 0, neutralCount: 0, totalCount: 0, score: 0 };
            }

            let redCount = 0;
            let greenCount = 0;
            let neutralCount = 0;
            let totalCount = 0;

            for (const market of Object.values(system.markets)) {
                totalCount++;
                if (market.stockRatio < 0.5) {
                    redCount++;
                } else if (market.stockRatio >= 0.8) {
                    greenCount++;
                } else {
                    neutralCount++;
                }
            }

            const score = totalCount > 0 ? (greenCount - redCount) / totalCount : 0;
            return { redCount, greenCount, neutralCount, totalCount, score };
        }

        function getSystemHeatColor(systemId) {
            const stats = getSystemHeatStats(systemId);
            if (stats.totalCount === 0) {
                return "rgba(148, 163, 184, 0.6)";
            }
            const t = (stats.score + 1) / 2;
            return interpolateColor("#f87171", "#10b981", t);
        }

        function interpolateColor(start, end, t) {
            const clampT = Math.max(0, Math.min(1, t));
            const startRgb = hexToRgb(start);
            const endRgb = hexToRgb(end);
            const r = Math.round(startRgb.r + (endRgb.r - startRgb.r) * clampT);
            const g = Math.round(startRgb.g + (endRgb.g - startRgb.g) * clampT);
            const b = Math.round(startRgb.b + (endRgb.b - startRgb.b) * clampT);
            return `rgb(${r}, ${g}, ${b})`;
        }

        function hexToRgb(hex) {
            const clean = hex.replace('#', '');
            const value = parseInt(clean, 16);
            return {
                r: (value >> 16) & 255,
                g: (value >> 8) & 255,
                b: value & 255,
            };
        }

        async function scrollToSystemRow(systemId) {
            marketState.selectedSystemId = systemId;
            document.getElementById('heatmap').style.display = 'block';
            let row = document.getElementById(`system-row-${systemId}`);
            if (!row) {
                try {
                    const data = await fetchMarketBatch(systemId, 1);
                    applyBatchData(data, null, true, null, true);
                    row = document.getElementById(`system-row-${systemId}`);
                } catch (error) {
                    return;
                }
            }

            if (!row) return;
            row.classList.add('active-row');
            row.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
            setTimeout(() => {
                row.classList.remove('active-row');
            }, 2000);
        }

        // Initial load
        refreshGalaxyMap();
        fetchMarketData();

        marketRefreshInterval = setInterval(fetchMarketData, MARKET_REFRESH_MS);
        mapRefreshInterval = setInterval(refreshGalaxyMap, MAP_REFRESH_MS);

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (marketRefreshInterval) clearInterval(marketRefreshInterval);
            if (mapRefreshInterval) clearInterval(mapRefreshInterval);
        });
    </script>
</body>
</html>
